---
title: "Automated and reproducible reports in R: a case study"
author: "Sonia Mazzi - Data Science Campus - ONS"
date: "6/3/2019"
output:
  html_document:
    fig_caption: false
    fig_width: 11
    fig_height: 6
    toc: true
    toc_depth: 2
    toc_float: true
    number_sections: true 
    theme: cosmo
---

<script>
   $(document).ready(function() {
     $head = $('#header');
     $head.prepend('<img src=\"dsclogo.png\" style=\"float: right;width: 150px;\"/>')
   });
</script>


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Objectives and pre-requisites

This case study is an example of a reproducible workflow.
We will follow the data science workflow: reflect, collect data, prepare data, analyse, report.

We would like to produce reports, by continent, on the status of HIV prevalence using the latest available data. 

Using data from Gapminder on HIV prevalence by country and year, together with other geographical and economic information, we will produce a single 
R markdown script that can generate reports on HIV prevalence for the different continents. Also, if new data arrives the same script can be used to update the report with the new information. The generated reports will be in html format as this is accessible and available to anyone with access to a web browser.
 
 <br>

The following are pre-requisites:

* Know how to import data in Excel format into R (package `readxl`).

* Understand the concept of tidy data and use the packages `tidyr` and `dplyr` for data wrangling.

* Know how to use the package `ggplot2` for data visualisation.

* Be familiar and at ease with literate programming in RStudio.

All pre-requisites are taught at the required level in "Data Science with R".

<br>

The following skills are needed: (we will learn about these in this workshop)

* Using R markdown: understanding the YAML header of a R Markdown document and how one can specify parameters here that the document will depend on. 
For more information on R Markdown see [R Markdown: The definitive guide](https://bookdown.org/yihui/rmarkdown/html-document.html).


* Using functional programming: we will learn how to use the function(al)s `map()` and `walk()` from the package `purrr` to apply a function to the entries of a vector or a list. This will be useful when we read the data in and also to generate all the reports, one per continent, at once. We also use conditional `if`-statements to add information to the report depending on the current parameters. `ifelse` statements are also used.


*  We will build on your `ggplot2` skills by learning how to use the package `maps` together with `ggplot2` in order to produce maps with statistical information in them.

* Be able to construct a simple function.

# Required libraries
```{r warning=FALSE, message=FALSE}
library(readxl)
library(ggplot2)
library(ggrepel)
library(dplyr)
library(tidyr)
library(purrr)
library(readr)
library(stringr)
library(maps)
```



# Importing the data

The data for this study is contained in the file "hiv_wb.xlsx".

This is clearly an Excel file. Let us explore it first.

Is this just one table or several tables arranged in a workbook?

```{r}
fn <- "hiv_wb.xlsx"
excel_sheets(fn)
```

There are many sheets in this workbook. Seemingly one sheet per year.

Let us explore the 2010 sheet (first sheet)

```{r}
hiv_2010 <- read_excel(fn, sheet=1)
head(hiv_2010)
```

We can see that we should skip the first 4 rows (the first row was interpreted as the row containing the column names. The default in `read_excel()` is to do that). Also we would like to trim any leading and trailing white space. 

Note that `hiv_prevalence`, `income` and `population` were read as character type.

Let us read the data in again.

```{r}
hiv_2010 <- read_excel(fn, sheet = 1, skip = 4, trim_ws = TRUE)
head(hiv_2010)
```
When we skip the first four rows the data reads in  well (as numeric).

Now we will read in all worksheets and combine them into a single table, stacking the tables for each year. We use the `map_df()` function from the `purrr` package in the Tidyverse. 

Note that for each sheet, entry in the vector `excel_sheets(fn)`, we apply the functions `read_excel()` followed by `mutate()` using `map_df()`. 

The function `map_df()` applies a function for each of the values of a vector, list or data frame and binds and stores the result in a single data frame (`combined_data` in this case).

In our case we have a vector, `excel_sheets(fn)` with the names of the sheets of the excel workbook named `fn`. The names of the sheets are the years. For each entry .x of the vector I wish to apply the function
`read_excel(fn, sheet = .x, skip = 4, trim_ws = TRUE) %>% mutate(year = as.integer(.x))`
which imports the sheet .x as a tibble and appends to it a new column called year, with numeric value .x. The successive tibbles are row-bound together to give the final output of one single tibble.

```{r}
#excel workbook file name
fn <- "hiv_wb.xlsx"

combined_data <- 
  excel_sheets(fn) %>% 
  map_df(~{read_excel(fn, sheet = .x, skip = 4, trim_ws = TRUE) %>% mutate(year = as.integer(.x))}) %>% 
  select(country, year, everything()) #this shuffles columns
```

The "~" before the function that is applied in `map_df()` denotes an "anonymous function" in this case it denotes the function `some_function`

```{r eval=F}
some_function <- function(.x){
  read_excel(fn, sheet = .x, skip = 4, trim_ws = TRUE) %>% 
    mutate(year = as.integer(.x))
  }
```

By using the "~" we just need to specify the actions of the function, simplifying the notation.

Let us explore `combined_data`.

```{r}
head(combined_data)

tail(combined_data)
```

Observational units are countries in the column `country`.

Variables are  `year`, `hiv_prevalence`, `income` and `population`.

This data set is in tidy format.

# Data preparation


We would like to add geographical information about the  countries, such as continent, region, standard three letter acronym, etc..

The second sheet in the file "DataGeographiesGapminder.xlsx" contains the information.

```{r}
fng <- "DataGeographiesGapminder.xlsx"
geo_dat <- read_excel(fng, sheet = 2)
head(geo_dat, n = 15)
```

Only keep the needed columns: `geo`, `name` and `four_regions`, `Latitude` and `Longitude`. The last two will be named `cen_Latitude` and `cen_Longitude` and they provide the coordinates for the center of the country.

```{r}
geo_data <- geo_dat %>% 
  select(country = name, geo, four_regions, cen_Latitude = Latitude, cen_Longitude = Longitude)

head(geo_data)
```

```{r}
hiv_full <- inner_join(combined_data, geo_data)
```

```{r}
glimpse(filter(hiv_full, year == 2010))
```


Sort the columns, fixed variables first.

```{r}
hiv_full <- hiv_full %>% 
  select(country, geo, continent = four_regions, everything())

glimpse(hiv_full)
```

<br>

We are interested in the percentual change of HIV prevalence from one year to the next, defined as 
$prevalence/lag(prevalence) - 1$. So, we add the  column `pct_chg_prevalence` to `hiv_full`.

```{r}
  hiv_full <- hiv_full  %>% 
  group_by(country) %>% 
  arrange(year, .by_group = TRUE) %>%
  mutate(pct_chg_prevalence = ifelse( lag(hiv_prevalence) != 0, ((hiv_prevalence/lag(hiv_prevalence) - 1) * 100), NA))
```


```{r}
glimpse(hiv_full)
```

<br>



## map data


We would like to plot continent maps and colour each country according to their level of HIV prevalence in the latest available year.

To do this we will use the R package `maps`.

Let us explore how we can combine the information in `hiv_full` with the geographical information in the `maps` package.

```{r}
world_map <- map_data("world")
head(world_map)
```
We can plot a world map



```{r}
ggplot(world_map) +
  geom_polygon(aes(x = long, y = lat, group = group), color = "black", fill = "gray") + 
  coord_quickmap()
```



The names of countries in `hiv_full` and `world` in `maps`, used to plot the map contours, don't coincide.
Let us explore this and clean the data.

**Africa**

This is the list of African countries from the `hiv_full` object.

```{r}
african_countries_raw <- hiv_full %>% 
  filter(continent == "africa") %>%
  pull(country) %>% 
  unique() %>% 
  sort()

african_countries_raw
```

This is the list of countries listed in the maps package object world that match the list above

```{r}
africa_map <- map_data("world") %>% 
  filter(region %in% african_countries_raw) %>% 
  mutate(country = region) %>% 
  pull(country) %>% 
  unique() %>% 
  sort()

africa_map
```

The countries in  `hiv_full` which do not appear in `africa_map` are

```{r}
setdiff(african_countries_raw, africa_map)
```

Let us find out the names of countries in `world_map` which contain the string "Congo"

```{r}
world_map %>% 
  mutate(aux = str_detect(region, "Congo")) %>% #aux is a new column with logical entries T or F
  filter(aux == T) %>% # retain the rows where aux is T
  select(region) %>% # keep the column  with country names
  unique() # eliminate duplicates
```

Let us find out the names of countries in `world_map` which contain the string "Ivo" (we are looking for what Cote d'Ivoire could be in `world_map`)

```{r}
world_map %>% 
  mutate(aux = str_detect(region, "Ivo")) %>% #aux is a new column with logical entries T or F
  filter(aux == T) %>% # retain the rows where aux is T
  select(region) %>% # keep the column  with country names
  unique() # eliminate duplicates
```




In the list of contries of world_map (`africa_map`),
"Democratic Republic of the Congo" is "Congo, Dem. Rep."
"Republic of Congo" is "Congo, Rep.",     
"Ivory Coast" is "Cote d'Ivoire".

Let us change these names in `hiv_full`.


```{r}
diff_names <- setdiff(african_countries_raw, africa_map)
new_names <- c("Democratic Republic of the Congo", "Republic of Congo", "Ivory Coast")
for (i in 1:length(diff_names)){
 hiv_full <- hiv_full %>% ungroup() %>%
   mutate(country = str_replace_all(country, diff_names[i], new_names[i])) 
}
```

One country is missing from `hiv_full` which is in `world_map`, namely "Western Sahara".
Libya has missing data for hiv prevalence so we will copy the data for Lybia and modify the `geo` (geo for Western Sahara is "esh"), `income`, `population`, and `country`.

```{r}
western_sahara <- hiv_full %>% 
  filter(country == "Libya") %>%
  mutate(geo = str_replace(geo, "lby", "esh")) %>%
  mutate(income = NA) %>%
  mutate(population = NA) %>%
  mutate(cen_Latitude = 24.155) %>%
  mutate(cen_longitude = 5) %>%
  mutate(country = str_replace(country, "Libya", "Western Sahara"))
```

Now let us add the data for Western Sahara to `hiv_full`.

```{r}
hiv_full <- bind_rows(hiv_full, western_sahara)
```


Now you try to reconcile the country names for Europe, Asia and the Americas.

